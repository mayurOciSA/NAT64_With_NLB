#!/bin/bash
set -euo pipefail

echo "=== NAT64 + TAYGA setup on Oracle Linux 9 (corrected IPv6 detection) ==="

##############################################
# 0. sanity: must be root
##############################################
if [ "$EUID" -ne 0 ]; then
echo "[ERROR] Please run as root."
exit 2
fi

##############################################
# 1. Detect primary interface dynamically
##############################################
# We detect the interface with the default IPv4 route (works behind NAT gateways too)
IFACE=$(ip route get 1.1.1.1 2>/dev/null | awk '{for(i=1;i<=NF;i++) if($i=="dev"){print $(i+1); exit}}')
if [ -z "$IFACE" ]; then
echo "[ERROR] Could not detect default IPv4 interface."
exit 3
fi
echo "[INFO] Primary interface detected: $IFACE"

##############################################
# 2. Fetch IPv4 and IPv6 addresses of $IFACE
#    - Use scope global to avoid fe80:: link-local addresses
##############################################
IPV4_ADDR=$(ip -4 -o addr show dev "$IFACE" scope global 2>/dev/null | awk '{print $4}' | cut -d/ -f1 | head -n1 || true)
IPV6_ADDR=$(ip -6 -o addr show dev "$IFACE" scope global 2>/dev/null | awk '{print $4}' | cut -d/ -f1 | head -n1 || true)

# Fallback behavior: if no global IPv6 found, leave empty but continue
if [ -z "$IPV4_ADDR" ]; then
echo "[ERROR] No global IPv4 address found on $IFACE. Aborting."
exit 4
fi

echo "[INFO] Interface IPv4: $IPV4_ADDR"
if [ -n "$IPV6_ADDR" ]; then
echo "[INFO] Interface IPv6 (global scope): $IPV6_ADDR"
else
echo "[WARN] No global IPv6 address found on $IFACE (only link-local maybe present). Continuing â€” Tayga can still accept IPv6 on other interfaces if configured."
fi

##############################################
# 3. Define NAT64 prefix + tayga pool (explicit)
##############################################
NAT64_PREFIX="64:ff9b::/96"        # RFC6052 well-known prefix
TAYGA_POOL="192.0.2.0/24"         # private/test pool for nat64 mapping (non-routable)
TAYGA_TUN="nat64"
TAYGA_TUN_IP="192.0.2.1"

echo "[INFO] NAT64 prefix: $NAT64_PREFIX"
echo "[INFO] Tayga IPv4 pool: $TAYGA_POOL"

echo "[INFO] Installing tayga (dnf)..."

while ! dnf install -y oracle-epel-release-el9; do
echo "[WARN] dnf install oracle-epel-release-el9 failed. Retrying in 10 seconds..."
sleep 3
done

while ! dnf config-manager --set-enabled ol9_developer_EPEL; do
echo "[WARN] dnf config-manager failed. Retrying in 10 seconds..."
sleep 3
done

while ! dnf install -y tayga; do
echo "[WARN] dnf install tayga failed. Retrying in 10 seconds..."
sleep 3
done

##############################################
# 5. Enable IPv4 & IPv6 forwarding (runtime)
##############################################
echo "[INFO] Enabling IPv4 and IPv6 forwarding..."
sysctl -w net.ipv4.ip_forward=1 >/dev/null
sysctl -w net.ipv6.conf.all.forwarding=1 >/dev/null

##############################################
# 6. Disable firewalld (we will use iptables)
##############################################
echo "[INFO] Stopping and disabling firewalld (if present)..."
systemctl stop firewalld 2>/dev/null || true
systemctl disable firewalld 2>/dev/null || true

##############################################
# 7. Create /etc/tayga.conf (explicit and ELI20 comments)
##############################################
cat >/etc/tayga.conf <<EOF
# Tayga config generated by script
# tun-device: virtual TUN device name used by tayga
tun-device $TAYGA_TUN

# IPv4 address assigned to the TUN device (virtual)
ipv4-addr $TAYGA_TUN_IP

# Assigns a Unique Local IPv6 Address (ULA) to the TUN device.
# Required for NAT64 operation when using the well-known prefix (64:ff9b::/96) and a private IPv4 pool.
# This address is used by TAYGA for IPv6-to-IPv4 translation and must be unique within your network.
ipv6-addr fd12:3456:789a::1

# IPv6 prefix used for IPv4-embedded addresses (RFC6052)
prefix $NAT64_PREFIX

# Dynamic pool: IPv4 pool tayga will allocate for translated hosts
dynamic-pool $TAYGA_POOL 
EOF

# Don't know why, but tayga service looks for nat64.conf specifically
cp /etc/tayga.conf /etc/tayga/nat64.conf

echo "[INFO] Wrote /etc/tayga.conf"

##############################################
# 8. Create the TUN device (idempotent)
##############################################
echo "[INFO] Creating TUN device via 'tayga --mktun' (idempotent)..."
# If the device already exists, tayga --mktun may error; ignore if already present
if ip link show "$TAYGA_TUN" >/dev/null 2>&1; then
echo "[INFO] TUN device $TAYGA_TUN already exists."
else
tayga --mktun
echo "[INFO] TUN device $TAYGA_TUN created."
fi

# Ensure the TUN has the expected IPv4 and is up (idempotent)
ip addr add "$TAYGA_TUN_IP/24" dev "$TAYGA_TUN" 2>/dev/null || true
ip link set dev "$TAYGA_TUN" up

##############################################
# 9. Add IPv6 route to deliver NAT64 prefix to tayga
##############################################
echo "[INFO] Adding IPv6 route for $NAT64_PREFIX -> dev $TAYGA_TUN"
ip -6 route replace $NAT64_PREFIX dev "$TAYGA_TUN"

##############################################
# 10. Configure iptables NAT for Tayga pool only (explicit)
##############################################
echo "[INFO] Flushing iptables nat & filter relevant chains (safe)"
iptables -t nat -F
iptables -F

# Only NAT packets originating from the tayga pool going out the primary interface
# MASQUERADE rewrites source IP to external interface IP and may rewrite source port (PAT) for uniqueness
echo "[INFO] Adding POSTROUTING MASQUERADE for Tayga pool -> out $IFACE"
iptables -t nat -A POSTROUTING -s $TAYGA_POOL -o "$IFACE" -j MASQUERADE

# Allow forwarding: nat64 <-> external interface

# First rule: allow new and established connections from TUN to external
iptables -I FORWARD 1 -i "$TAYGA_TUN" -o "$IFACE" -j ACCEPT

# Second rule: allow only established/related connections from external to TUN (secure, blocks unsolicited inbound)
iptables -I FORWARD 1 -i "$IFACE" -o "$TAYGA_TUN" -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT

# Allow ICMPv6 for PMTU and basic operations
ip6tables -I FORWARD 1 -p icmpv6 -j ACCEPT

# Adjust TCP MSS to 1220 for faster PMTUD to IPv4 internet hosts
echo "[INFO] Adding TCPMSS iptables rules to adjust MSS to 1220 bytes"
iptables -t mangle -A FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --set-mss 1220
ip6tables -t mangle -A FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --set-mss 1220

# From ULA clients you can explore the PMTUD with following commands:
# ping -6 -c 1 -M do -s 1450 64:ff9b::195.181.172.6
# &  Specifically for tcp connections
#    watch -n 2 ss -6tnio dst "[64:ff9b::195.181.172.5]"

##############################################
# 11. Start / restart tayga service
##############################################
echo "[INFO] Starting tayga service (systemd)..."
# Ensure systemd knows about tayga; restart to pick up /etc/tayga.conf
systemctl daemon-reload || true
systemctl enable tayga@nat64
systemctl restart tayga@nat64

# Give a moment and then show status
sleep 3
systemctl is-active --quiet tayga@nat64 && echo "[INFO] tayga is running" || echo "[WARN] tayga not running; check 'journalctl -u tayga@nat64'"

##############################################
# 12. Show final information
##############################################
echo ""
echo "=== Summary ==="
echo "Primary interface: $IFACE"
echo "Primary IPv4: $IPV4_ADDR"
if [ -n "$IPV6_ADDR" ]; then
echo "Primary IPv6 (global scope): $IPV6_ADDR"
else
echo "Primary IPv6 (global scope): NONE found"
fi
echo "Tayga TUN: $TAYGA_TUN ($TAYGA_TUN_IP)"
echo "Tayga pool: $TAYGA_POOL"
echo "NAT64 prefix: $NAT64_PREFIX"

echo ""
echo "Useful debug:"
echo "  ip -6 route | grep $NAT64_PREFIX || true"
echo "  ip addr show $TAYGA_TUN"
echo "  iptables -t nat -S"
echo "  iptables -S"

echo ""
echo "[DONE] NAT64 (tayga) setup script finished."

# Print key conntrack timeouts (TCP, UDP, ICMP)
echo "=== Conntrack Default Timeout Values ==="
for p in nf_conntrack_tcp_timeout_established nf_conntrack_udp_timeout nf_conntrack_icmp_timeout; do
echo "$p: $(sysctl -n net.netfilter.$p 2>/dev/null) seconds"
done

##############################################
# 13. Add essential iptables INPUT rules (SSH, established)
##############################################
echo "[INFO] Adding essential INPUT rules to allow SSH and established connections..."
# Allow all traffic on the loopback interface (critical for many services)
iptables -A INPUT -i lo -j ACCEPT
# Allow return traffic for connections initiated by the server
iptables -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT

# Allow new incoming SSH connections on the primary interface
iptables -A INPUT -p tcp -i "$IFACE" --dport 22 -j ACCEPT
# Allow ICMP echo requests (ping)
iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT


echo "systemctl status tayga@nat64"
systemctl status tayga@nat64 --no-pager
echo "journalctl -u tayga@nat64 --no-pager | tail -20"
journalctl -u tayga@nat64 --no-pager | tail -20

# (sleep 2; ping6 -c3 64:ff9b::8.8.8.8) &
# tcpdump -i nat64 -n -vv -c 10 'icmp6 or icmp'
dnf install -y nc conntrack-tools wireshark-cli

# echo "Starting tcpdump in background to capture all traffic for 3 hours to /tmp/traffic_capture.pcap rotationally to sigle file"
# nohup tcpdump -i any -s 0 -w /tmp/traffic_capture.pcap -v -v -v -tttt -G 10800 -W 1 2>&1 &
# echo "Use one of below on node to see capture"
# echo "tcpdump -vvv -ttt -r /tmp/traffic_capture.pcap -A -l"
# echo "tshark -r /tmp/traffic_capture.pcap -T text -V -l"

echo "[SCRIPT COMPLETE]"